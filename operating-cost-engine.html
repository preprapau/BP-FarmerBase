/* =========================================================
   Farmerbase BP Engine
   Advanced Cost Allocation Engine (FINAL)
   ---------------------------------------------------------
   - Uses PRODUCTION_MASTER
   - Uses project.expenses
   - Checklist-based allocation (appliesTo: array)
   - Operating cost only
   - Fixed cost excluded (used in ROI module)
   ========================================================= */

(function () {

  /* ---------- Helpers ---------- */

  function getActiveProject() {
    const key = localStorage.getItem("activeProject");
    if (!key) return null;
    return {
      key: key,
      data: JSON.parse(localStorage.getItem(key)) || {}
    };
  }

  function getProduction() {
    return JSON.parse(
      localStorage.getItem("PRODUCTION_MASTER")
    ) || [];
  }

  /* ---------- Core Engine ---------- */

  function runCostAllocation() {

    const projectWrap = getActiveProject();
    if (!projectWrap) return null;

    const project = projectWrap.data;
    const expenses = project.expenses || [];
    const products = getProduction();

    let allocation = {};

    /* STEP 1: Prepare production base */
    products.forEach(p => {
      const qty = Number(p.qty) || 0;
      if (qty === 0) return;

      allocation[p.id] = {
        productId: p.id,
        name: p.name,
        qty: qty,
        unit: p.unit || "",
        directCost: 0,
        allocatedCost: 0,
        totalCost: 0,
        unitCost: 0
      };
    });

    /* STEP 2: Take operating expenses only */
    const operatingExpenses = expenses.filter(e =>
      e.costType === "operating" &&
      Array.isArray(e.appliesTo) &&
      Number(e.amount) > 0
    );

    /* STEP 3: Allocate expenses */
    operatingExpenses.forEach(e => {

      const amount = Number(e.amount) || 0;
      if (amount === 0) return;

      /* Case A: applies to ALL products */
      if (e.appliesTo.includes("all")) {

        const totalQty = Object.values(allocation)
          .reduce((sum, p) => sum + p.qty, 0);

        Object.values(allocation).forEach(p => {
          const share = totalQty > 0
            ? (p.qty / totalQty) * amount
            : 0;
          p.allocatedCost += share;
        });

      }
      /* Case B: applies to selected products only */
      else {

        const targets = e.appliesTo.filter(id => allocation[id]);
        if (targets.length === 0) return;

        const targetQty = targets.reduce(
          (sum, id) => sum + allocation[id].qty, 0
        );

        targets.forEach(id => {
          const p = allocation[id];
          const share = targetQty > 0
            ? (p.qty / targetQty) * amount
            : 0;
          p.directCost += share;
        });
      }
    });

    /* STEP 4: Final per-unit cost */
    Object.values(allocation).forEach(p => {
      p.totalCost = p.directCost + p.allocatedCost;
      p.unitCost = p.qty > 0
        ? p.totalCost / p.qty
        : 0;
    });

    /* STEP 5: Save back to project */
    project.costAllocation = allocation;
    localStorage.setItem(
      projectWrap.key,
      JSON.stringify(project)
    );

    return allocation;
  }

  /* ---------- Auto Run ---------- */
  runCostAllocation();

  /* ---------- Expose (for debug / re-run) ---------- */
  window.runCostAllocation = runCostAllocation;

})();
